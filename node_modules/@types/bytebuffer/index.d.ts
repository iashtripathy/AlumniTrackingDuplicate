// Type definitions for bytebuffer.js 5.0.0
// Project: https://github.com/dcodeIO/bytebuffer.js
<<<<<<< HEAD
// Definitions by: Denis Cappellin <https://github.com/dcappellin>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// Definitions by: SINTEF-9012 <https://github.com/SINTEF-9012>
// Definitions by: Marek Urbanowicz <https://github.com/murbanowicz>

/// <reference types="node" />
import Long = require('long');
=======
// Definitions by: Denis Cappellin <https://github.com/cappellin>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// Definitions by: SINTEF-9012 <https://github.com/SINTEF-9012>

/// <reference types="node" />
import Long = require("long");
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

declare namespace ByteBuffer {}
export = ByteBuffer;
export as namespace ByteBuffer;

<<<<<<< HEAD
declare class ByteBuffer {
    /**
     * Constructs a new ByteBuffer.
     */
    constructor(capacity?: number, littleEndian?: boolean, noAssert?: boolean);
=======
declare class ByteBuffer
{
    /**
     * Constructs a new ByteBuffer.
     */
    constructor( capacity?: number, littleEndian?: boolean, noAssert?: boolean );
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Big endian constant that can be used instead of its boolean value. Evaluates to false.
     */
    static BIG_ENDIAN: boolean;

    /**
     * Default initial capacity of 16.
     */
    static DEFAULT_CAPACITY: number;

    /**
     * Default endianess of false for big endian.
     */
    static DEFAULT_ENDIAN: boolean;

    /**
     * Default no assertions flag of false.
     */
    static DEFAULT_NOASSERT: boolean;

    /**
     * Little endian constant that can be used instead of its boolean value. Evaluates to true.
     */
    static LITTLE_ENDIAN: boolean;

    /**
     * Maximum number of bytes required to store a 32bit base 128 variable-length integer.
     */
    static MAX_VARINT32_BYTES: number;

    /**
     * Maximum number of bytes required to store a 64bit base 128 variable-length integer.
     */
    static MAX_VARINT64_BYTES: number;

    /**
     * Metrics representing number of bytes.Evaluates to 2.
     */
    static METRICS_BYTES: number;

    /**
     * Metrics representing number of UTF8 characters.Evaluates to 1.
     */
    static METRICS_CHARS: number;

    /**
     * ByteBuffer version.
     */
    static VERSION: string;

    /**
     * Backing buffer.
     */
    buffer: Buffer;

    /**
     * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
     */
    limit: number;

    /**
     * Whether to use little endian byte order, defaults to false for big endian.
     */
    littleEndian: boolean;

    /**
     * Marked offset.
     */
    markedOffset: number;

    /**
     * Whether to skip assertions of offsets and values, defaults to false.
     */
    noAssert: boolean;

    /**
     * Absolute read/write offset.
     */
    offset: number;

    /**
     * Data view to manipulate the backing buffer. Becomes null if the backing buffer has a capacity of 0.
     */
    view: DataView;

    /**
     * Allocates a new ByteBuffer backed by a buffer of the specified capacity.
     */
<<<<<<< HEAD
    static allocate(capacity?: number, littleEndian?: boolean, noAssert?: boolean): ByteBuffer;
=======
    static allocate( capacity?: number, littleEndian?: boolean, noAssert?: boolean ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Decodes a base64 encoded string to binary like window.atob does.
     */
<<<<<<< HEAD
    static atob(b64: string): string;
=======
    static atob( b64: string ): string;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Encodes a binary string to base64 like window.btoa does.
     */
<<<<<<< HEAD
    static btoa(str: string): string;
=======
    static btoa( str: string ): string;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Calculates the number of UTF8 bytes of a string.
     */
<<<<<<< HEAD
    static calculateUTF8Bytes(str: string): number;
=======
    static calculateUTF8Bytes( str: string ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Calculates the number of UTF8 characters of a string.JavaScript itself uses UTF- 16, so that a string's length property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
     */
<<<<<<< HEAD
    static calculateUTF8Chars(str: string): number;
=======
    static calculateUTF8Chars( str: string ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Calculates the number of UTF8 bytes of a string. This is an alias of ByteBuffer#calculateUTF8Bytes.
     */
<<<<<<< HEAD
    static calculateString(str: string): number;
=======
    static calculateString( str: string ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
     */
<<<<<<< HEAD
    static calculateVarint32(value: number): number;
=======
    static calculateVarint32( value: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
     */
<<<<<<< HEAD
    static calculateVarint64(value: number | Long): number;
=======
    static calculateVarint64( value: number | Long ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Concatenates multiple ByteBuffers into one.
     */
<<<<<<< HEAD
    static concat(
        buffers: Array<ByteBuffer | Buffer | ArrayBuffer | Uint8Array | string>,
        encoding?: string | boolean,
        litteEndian?: boolean,
        noAssert?: boolean,
    ): ByteBuffer;
=======
    static concat( buffers: Array<ByteBuffer | Buffer | ArrayBuffer | Uint8Array | string>, encoding?: string | boolean, litteEndian?: boolean, noAssert?: boolean ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Decodes a base64 encoded string to a ByteBuffer.
     */
<<<<<<< HEAD
    static fromBase64(str: string, littleEndian?: boolean, noAssert?: boolean): ByteBuffer;
=======
    static fromBase64( str: string, littleEndian?: boolean, noAssert?: boolean ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.
     */
<<<<<<< HEAD
    static fromBinary(str: string, littleEndian?: boolean, noAssert?: boolean): ByteBuffer;
=======
    static fromBinary( str: string, littleEndian?: boolean, noAssert?: boolean ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Decodes a hex encoded string with marked offsets to a ByteBuffer.
     */
<<<<<<< HEAD
    static fromDebug(str: string, littleEndian?: boolean, noAssert?: boolean): ByteBuffer;
=======
    static fromDebug( str: string, littleEndian?: boolean, noAssert?: boolean ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Decodes a hex encoded string to a ByteBuffer.
     */
<<<<<<< HEAD
    static fromHex(str: string, littleEndian?: boolean, noAssert?: boolean): ByteBuffer;
=======
    static fromHex( str: string, littleEndian?: boolean, noAssert?: boolean ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Decodes an UTF8 encoded string to a ByteBuffer.
     */
<<<<<<< HEAD
    static fromUTF8(str: string, littleEndian?: boolean, noAssert?: boolean): ByteBuffer;
=======
    static fromUTF8( str: string, littleEndian?: boolean, noAssert?: boolean ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Gets the backing buffer type.
     */
<<<<<<< HEAD
    static isByteBuffer(bb: any): boolean;
=======
    static isByteBuffer( bb: any ): boolean;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Wraps a buffer or a string. Sets the allocated ByteBuffer's ByteBuffer#offset to 0 and its ByteBuffer#limit to the length of the wrapped data.
     * @param buffer Anything that can be wrapped
     * @param encoding String encoding if buffer is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param littleEndian Whether to use little or big endian byte order. Defaults to ByteBuffer.DEFAULT_ENDIAN.
     * @param noAssert Whether to skip assertions of offsets and values. Defaults to ByteBuffer.DEFAULT_NOASSERT.
     */
<<<<<<< HEAD
    static wrap(
        buffer: ByteBuffer | Buffer | ArrayBuffer | Uint8Array | string,
        enc?: string | boolean,
        littleEndian?: boolean,
        noAssert?: boolean,
    ): ByteBuffer;
=======
    static wrap( buffer: ByteBuffer | Buffer | ArrayBuffer | Uint8Array | string, enc?: string | boolean, littleEndian?: boolean, noAssert?: boolean ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Decodes a zigzag encoded signed 32bit integer.
     */
<<<<<<< HEAD
    static zigZagDecode32(n: number): number;
=======
    static zigZagDecode32( n: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Decodes a zigzag encoded signed 64bit integer.
     */
<<<<<<< HEAD
    static zigZagDecode64(n: number | Long): Long;
=======
    static zigZagDecode64( n: number | Long ): Long;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
     */
<<<<<<< HEAD
    static zigZagEncode32(n: number): number;
=======
    static zigZagEncode32( n: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
     */
<<<<<<< HEAD
    static zigZagEncode64(n: number | Long): Long;
=======
    static zigZagEncode64( n: number | Long ): Long;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Switches (to) big endian byte order.
     */
<<<<<<< HEAD
    BE(bigEndian?: boolean): this;
=======
    BE( bigEndian?: boolean ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Switches (to) little endian byte order.
     */
<<<<<<< HEAD
    LE(bigEndian?: boolean): this;
=======
    LE( bigEndian?: boolean ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended data's length.
     */
<<<<<<< HEAD
    append(
        source: ByteBuffer | Buffer | ArrayBuffer | Uint8Array | string,
        encoding?: string | number,
        offset?: number,
    ): this;
=======
    append( source: ByteBuffer | Buffer | ArrayBuffer | Uint8Array | string, encoding?: string | number, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents behind the specified offset up to the length of this ByteBuffer's data.
     */
<<<<<<< HEAD
    appendTo(target: ByteBuffer, offset?: number): this;
=======
    appendTo( target: ByteBuffer, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to disable them if your code already makes sure that everything is valid.
     */
<<<<<<< HEAD
    assert(assert: boolean): this;
=======
    assert( assert: boolean ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Gets the capacity of this ByteBuffer's backing buffer.
     */
    capacity(): number;

    /**
     * Clears this ByteBuffer's offsets by setting ByteBuffer#offset to 0 and
     * ByteBuffer#limit to the backing buffer's capacity. Discards ByteBuffer#markedOffset.
     */
<<<<<<< HEAD
    clear(): this;
=======
    clear(): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for ByteBuffer#offset, ByteBuffer#markedOffset and ByteBuffer#limit.
     */
<<<<<<< HEAD
    clone(copy?: boolean): ByteBuffer;
=======
    clone( copy?: boolean ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Compacts this ByteBuffer to be backed by a ByteBuffer#buffer of its contents' length. Contents are the bytes between ByteBuffer#offset and ByteBuffer#limit. Will set offset = 0 and limit = capacity and adapt ByteBuffer#markedOffset to the same relative position if set.
     */
<<<<<<< HEAD
    compact(begin?: number, end?: number): this;
=======
    compact( begin?: number, end?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Creates a copy of this ByteBuffer's contents. Contents are the bytes between ByteBuffer#offset and ByteBuffer#limit.
     */
<<<<<<< HEAD
    copy(begin?: number, end?: number): ByteBuffer;
=======
    copy( begin?: number, end?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between ByteBuffer#offset and ByteBuffer#limit.
     */
<<<<<<< HEAD
    copyTo(target: ByteBuffer, targetOffset?: number, sourceOffset?: number, sourceLimit?: number): this;
=======
    copyTo( target: ByteBuffer, targetOffset?: number, sourceOffset?: number, sourceLimit?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Makes sure that this ByteBuffer is backed by a ByteBuffer#buffer of at least the specified capacity. If the current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity, the required capacity will be used instead.
     */
<<<<<<< HEAD
    ensureCapacity(capacity: number): this;
=======
    ensureCapacity( capacity: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between ByteBuffer#offset and ByteBuffer#limit.
     */
<<<<<<< HEAD
    fill(value: number | string, begin?: number, end?: number): this;
=======
    fill( value: number | string, begin?: number, end?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets limit = offset and offset = 0. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.
     */
<<<<<<< HEAD
    flip(): this;
=======
    flip(): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Marks an offset on this ByteBuffer to be used later.
     */
<<<<<<< HEAD
    mark(offset?: number): this;
=======
    mark( offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Sets the byte order.
     */
<<<<<<< HEAD
    order(littleEndian: boolean): this;
=======
    order( littleEndian: boolean ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the prepended data's length. If there is not enough space available before the specified offset, the backing buffer will be resized and its contents moved accordingly.
     */
<<<<<<< HEAD
    prepend(
        source: ByteBuffer | string | ArrayBuffer | Buffer,
        encoding?: string | number,
        offset?: number,
    ): this;
=======
    prepend( source: ByteBuffer | string | ArrayBuffer | Buffer, encoding?: string | number, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the prepended data's length. If there is not enough space available before the specified offset, the backing buffer will be resized and its contents moved accordingly.
     */
<<<<<<< HEAD
    prependTo(target: ByteBuffer, offset?: number): this;
=======
    prependTo( target: ByteBuffer, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Prints debug information about this ByteBuffer's contents.
     */
<<<<<<< HEAD
    printDebug(out?: (text: string) => void): void;
=======
    printDebug( out?: ( text: string ) => void ): void;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads an 8bit signed integer. This is an alias of ByteBuffer#readInt8.
     */
<<<<<<< HEAD
    readByte(offset?: number): number;
=======
    readByte( offset?: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads the specified number of bytes
     */
<<<<<<< HEAD
    readBytes(length: number, offset?: number): ByteBuffer;
=======
    readBytes( length: number, offset?: number): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters itself.
     */
<<<<<<< HEAD
    readCString(): string;
    readCString(offset: number): { string: string; length: number };
=======
    readCString( offset?: number ): string;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a 64bit float. This is an alias of ByteBuffer#readFloat64.
     */
<<<<<<< HEAD
    readDouble(offset?: number): number;
=======
    readDouble( offset?: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a 32bit float. This is an alias of ByteBuffer#readFloat32.
     */
<<<<<<< HEAD
    readFloat(offset?: number): number;
=======
    readFloat( offset?: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a 32bit float.
     */
<<<<<<< HEAD
    readFloat32(offset?: number): number;
=======
    readFloat32( offset?: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a 64bit float.
     */
<<<<<<< HEAD
    readFloat64(offset?: number): number;
=======
    readFloat64( offset?: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a length as uint32 prefixed UTF8 encoded string.
     */
<<<<<<< HEAD
    readIString(): string;
    readIString(offset: number): { string: string; length: number };
=======
    readIString( offset?: number ): string | { string: string; length: number };
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a 32bit signed integer.This is an alias of ByteBuffer#readInt32.
     */
<<<<<<< HEAD
    readInt(offset?: number): number;
=======
    readInt( offset?: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a 16bit signed integer.
     */
<<<<<<< HEAD
    readInt16(offset?: number): number;
=======
    readInt16( offset?: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a 32bit signed integer.
     */
<<<<<<< HEAD
    readInt32(offset?: number): number;
=======
    readInt32( offset?: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a 64bit signed integer.
     */
<<<<<<< HEAD
    readInt64(offset?: number): Long;
=======
    readInt64( offset?: number ): Long;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads an 8bit signed integer.
     */
<<<<<<< HEAD
    readInt8(offset?: number): number;
=======
    readInt8( offset?: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a 64bit signed integer. This is an alias of ByteBuffer#readInt64.
     */
<<<<<<< HEAD
    readLong(offset?: number): Long;
=======
    readLong( offset?: number ): Long;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a 16bit signed integer. This is an alias of ByteBuffer#readInt16.
     */
<<<<<<< HEAD
    readShort(offset?: number): number;
=======
    readShort( offset?: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads an UTF8 encoded string. This is an alias of ByteBuffer#readUTF8String.
     */
<<<<<<< HEAD
    readString(length: number, metrics?: number): string;
    readString(length: number, metrics: number, offset: number): { string: string; length: number };
=======
    readString( length: number, metrics?: number, offset?: number ): string;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads an UTF8 encoded string.
     */
<<<<<<< HEAD
    readUTF8String(chars: number, metrics?: number): string;
    readUTF8String(chars: number, metrics: number, offset: number): { string: string; length: number };
=======
    readUTF8String( chars: number, metrics?: number, offset?: number ): string | { string: string; length: number };
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a 16bit unsigned integer.
     */
<<<<<<< HEAD
    readUint16(offset?: number): number;
=======
    readUint16( offset?: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a 32bit unsigned integer.
     */
<<<<<<< HEAD
    readUint32(offset?: number): number;
=======
    readUint32( offset?: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a 64bit unsigned integer.
     */
<<<<<<< HEAD
    readUint64(offset?: number): Long;
    /**
     * Reads an 8bit unsigned integer.
     */
    readUint8(offset?: number): number;
=======
    readUint64( offset?: number ): Long;
    /**
     * Reads an 8bit unsigned integer.
     */
    readUint8( offset?: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a length as varint32 prefixed UTF8 encoded string.
     */
<<<<<<< HEAD
    readVString(): string;
    readVString(offset: number): { string: string; length: number };
=======
    readVString( offset?: number ): string;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a 32bit base 128 variable-length integer.
     */
<<<<<<< HEAD
    readVarint32(): number;
    readVarint32(offset: number): { value: number; length: number };
=======
    readVarint32( offset?: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a zig-zag encoded 32bit base 128 variable-length integer.
     */
<<<<<<< HEAD
    readVarint32ZigZag(): number;
    readVarint32ZigZag(offset: number): { value: number; length: number };
=======
    readVarint32ZigZag( offset?: number ): number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a 64bit base 128 variable-length integer. Requires Long.js.
     */
<<<<<<< HEAD
    readVarint64(): Long;
    readVarint64(offset: number): { value: Long; length: number };
=======
    readVarint64( offset?: number ): Long;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
     */
<<<<<<< HEAD
    readVarint64ZigZag(): Long;
    readVarint64ZigZag(offset: number): { value: Long; length: number };
=======
    readVarint64ZigZag( offset?: number ): Long;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Gets the number of remaining readable bytes. Contents are the bytes between ByteBuffer#offset and ByteBuffer#limit, so this returns limit - offset.
     */
    remaining(): number;

    /**
     * Resets this ByteBuffer's ByteBuffer#offset. If an offset has been marked through ByteBuffer#mark before, offset will be set to ByteBuffer#markedOffset, which will then be discarded. If no offset has been marked, sets offset = 0.
     */
<<<<<<< HEAD
    reset(): this;
=======
    reset(): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that large or larger.
     */
<<<<<<< HEAD
    resize(capacity: number): this;
=======
    resize( capacity: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Reverses this ByteBuffer's contents
     */
<<<<<<< HEAD
    reverse(begin?: number, end?: number): this;
=======
    reverse( begin?: number, end?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Skips the next length bytes. This will just advance
     */
<<<<<<< HEAD
    skip(length: number): this;
=======
    skip( length: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Slices this ByteBuffer by creating a cloned instance with offset = begin and limit = end.
     */
<<<<<<< HEAD
    slice(begin?: number, end?: number): ByteBuffer;
=======
    slice( begin?: number, end?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between ByteBuffer#offset and ByteBuffer#limit. Will transparently ByteBuffer#flip this ByteBuffer if offset > limit but the actual offsets remain untouched. This is an alias of ByteBuffer#toBuffer.
     */
<<<<<<< HEAD
    toArrayBuffer(forceCopy?: boolean): ArrayBuffer;
=======
    toArrayBuffer( forceCopy?: boolean ): ArrayBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Encodes this ByteBuffer's contents to a base64 encoded string.
     */
<<<<<<< HEAD
    toBase64(begin?: number, end?: number): string;
=======
    toBase64( begin?: number, end?: number ): string;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.
     */
<<<<<<< HEAD
    toBinary(begin?: number, end?: number): string;
=======
    toBinary( begin?: number, end?: number ): string;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between ByteBuffer#offset and ByteBuffer#limit. Will transparently ByteBuffer#flip this ByteBuffer if offset > limit but the actual offsets remain untouched.
     */
<<<<<<< HEAD
    toBuffer(forceCopy?: boolean): Buffer;

    /**
     *Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
=======
    toBuffer( forceCopy?: boolean ): Buffer;

    /**
      *Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
>>>>>>> bd5102a38a195cc780d136133078667941b408c9
     *  < : offset,
     *  ' : markedOffset,
     *  > : limit,
     *  | : offset and limit,
     *  [ : offset and markedOffset,
     *  ] : markedOffset and limit,
     *  ! : offset, markedOffset and limit
     */
<<<<<<< HEAD
    toDebug(columns?: boolean): string | Array<string>;
=======
    toDebug( columns?: boolean ): string | Array<string>
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Encodes this ByteBuffer's contents to a hex encoded string.
     */
<<<<<<< HEAD
    toHex(begin?: number, end?: number): string;
=======
    toHex( begin?: number, end?: number ): string;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Converts the ByteBuffer's contents to a string.
     */
<<<<<<< HEAD
    toString(encoding?: string): string;
=======
    toString( encoding?: string ): string;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Encodes this ByteBuffer's contents between ByteBuffer#offset and ByteBuffer#limit to an UTF8 encoded string.
     */
    toUTF8(): string;

    /**
     * Writes an 8bit signed integer. This is an alias of ByteBuffer#writeInt8.
     */
<<<<<<< HEAD
    writeByte(value: number, offset?: number): this;
=======
    writeByte( value: number, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes an array of bytes. This is an alias for append
     */
<<<<<<< HEAD
    writeBytes(
        source: ByteBuffer | Buffer | ArrayBuffer | Uint8Array | string,
        encoding?: string | number,
        offset?: number,
    ): this;
=======
    writeBytes( source: ByteBuffer | Buffer | ArrayBuffer | Uint8Array | string, encoding?: string | number, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL characters itself.
     */
<<<<<<< HEAD
    writeCString(str: string, offset?: number): this;
=======
    writeCString( str: string, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a 64bit float. This is an alias of ByteBuffer#writeFloat64.
     */
<<<<<<< HEAD
    writeDouble(value: number, offset?: number): this;
=======
    writeDouble( value: number, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a 32bit float. This is an alias of ByteBuffer#writeFloat32.
     */
<<<<<<< HEAD
    writeFloat(value: number, offset?: number): this;
=======
    writeFloat( value: number, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a 32bit float.
     */
<<<<<<< HEAD
    writeFloat32(value: number, offset?: number): this;
=======
    writeFloat32( value: number, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a 64bit float.
     */
<<<<<<< HEAD
    writeFloat64(value: number, offset?: number): this;
=======
    writeFloat64( value: number, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a length as uint32 prefixed UTF8 encoded string.
     */
<<<<<<< HEAD
    writeIString(str: string, offset?: number): this;
=======
    writeIString( str: string, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a 32bit signed integer. This is an alias of ByteBuffer#writeInt32.
     */
<<<<<<< HEAD
    writeInt(value: number, offset?: number): this;
=======
    writeInt( value: number, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a 16bit signed integer.
     */
<<<<<<< HEAD
    writeInt16(value: number, offset?: number): this;
=======
    writeInt16( value: number, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a 32bit signed integer.
     */
<<<<<<< HEAD
    writeInt32(value: number, offset?: number): this;
=======
    writeInt32( value: number, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a 64bit signed integer.
     */
<<<<<<< HEAD
    writeInt64(value: number | Long, offset?: number): this;
=======
    writeInt64( value: number | Long, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes an 8bit signed integer.
     */
<<<<<<< HEAD
    writeInt8(value: number, offset?: number): this;
=======
    writeInt8( value: number, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Write a 64bit signed integer. This is an alias of ByteBuffer#writeInt64.
     */
<<<<<<< HEAD
    writeLong(value: number | Long, offset?: number): this;
=======
     writeLong( value: number | Long, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a 16bit signed integer. This is an alias of ByteBuffer#writeInt16.
     */
<<<<<<< HEAD
    writeShort(value: number, offset?: number): this;
=======
    writeShort( value: number, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes an UTF8 encoded string. This is an alias of ByteBuffer#writeUTF8String.
     */
<<<<<<< HEAD
    writeString(str: string): this;
    writeString(str: string, offset: number): number;
=======
    writeString( str: string, offset?: number ): ByteBuffer | number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes an UTF8 encoded string.
     */
<<<<<<< HEAD
    writeUTF8String(str: string): this;
    writeUTF8String(str: string, offset?: number): number;
=======
    writeUTF8String( str: string, offset?: number ): ByteBuffer | number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a 16bit unsigned integer.
     */
<<<<<<< HEAD
    writeUint16(value: number, offset?: number): this;
=======
    writeUint16( value: number, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a 32bit unsigned integer.
     */
<<<<<<< HEAD
    writeUint32(value: number, offset?: number): this;
=======
    writeUint32( value: number, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a 64bit unsigned integer.
     */
<<<<<<< HEAD
    writeUint64(value: number | Long, offset?: number): this;
=======
    writeUint64( value: number | Long, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes an 8bit unsigned integer.
     */
<<<<<<< HEAD
    writeUint8(value: number, offset?: number): this;
=======
    writeUint8( value: number, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a length as varint32 prefixed UTF8 encoded string.
     */
<<<<<<< HEAD
    writeVString(str: string): this;
    writeVString(str: string, offset: number): number;
=======
    writeVString( str: string, offset?: number ): ByteBuffer | number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a 32bit base 128 variable-length integer.
     */
<<<<<<< HEAD
    writeVarint32(value: number): this;
    writeVarint32(value: number, offset: number): number;
=======
    writeVarint32( value: number, offset?: number ): ByteBuffer | number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a zig-zag encoded 32bit base 128 variable-length integer.
     */
<<<<<<< HEAD
    writeVarint32ZigZag(value: number): this;
    writeVarint32ZigZag(value: number, offset: number): number;
=======
    writeVarint32ZigZag( value: number, offset?: number ): ByteBuffer | number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a 64bit base 128 variable-length integer.
     */
<<<<<<< HEAD
    writeVarint64(value: number | Long): this;
    writeVarint64(value: number | Long, offset: number): number;
=======
    writeVarint64( value: number | Long, offset?: number ): ByteBuffer;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    /**
     * Writes a zig-zag encoded 64bit base 128 variable-length integer.
     */
<<<<<<< HEAD
    writeVarint64ZigZag(value: number | Long): this;
    writeVarint64ZigZag(value: number | Long, offset: number): number;
=======
    writeVarint64ZigZag( value: number | Long, offset?: number ): ByteBuffer | number;
>>>>>>> bd5102a38a195cc780d136133078667941b408c9
}
