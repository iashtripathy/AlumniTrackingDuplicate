<<<<<<< HEAD
var fs = require('fs')
var path = require('path')
=======
var fs = require('fs'),
  path = require('path')
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

// add bash completions to your
//  yargs-powered applications.
module.exports = function (yargs, usage) {
  var self = {
    completionKey: 'get-yargs-completions'
  }

  // get a list of completion commands.
  self.getCompletion = function (done) {
<<<<<<< HEAD
    var completions = []
    var current = process.argv[process.argv.length - 1]
    var previous = process.argv.slice(process.argv.indexOf('--' + self.completionKey) + 1)
    var argv = yargs.parse(previous)
=======
    var completions = [],
    current = process.argv[process.argv.length - 1],
    previous = process.argv.slice(process.argv.indexOf('--' + self.completionKey) + 1),
    argv = yargs.parse(previous)
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    // a custom completion function can be provided
    // to completion().
    if (completionFunction) {
      if (completionFunction.length < 3) {
<<<<<<< HEAD
        var result = completionFunction(current, argv)

        // promise based completion function.
        if (typeof result.then === 'function') {
          return result.then(function (list) {
            process.nextTick(function () { done(list) })
          }).catch(function (err) {
            process.nextTick(function () { throw err })
          })
        }

        // synchronous completion function.
        return done(result)
=======
        // synchronous completion function.
        return done(completionFunction(current, argv))
>>>>>>> bd5102a38a195cc780d136133078667941b408c9
      } else {
        // asynchronous completion function
        return completionFunction(current, argv, function (completions) {
          done(completions)
        })
      }
    }

<<<<<<< HEAD
    var handlers = yargs.getCommandHandlers()
    for (var i = 0, ii = previous.length; i < ii; ++i) {
      if (handlers[previous[i]]) {
        return handlers[previous[i]](yargs.reset())
      }
    }

    if (!current.match(/^-/)) {
      usage.getCommands().forEach(function (command) {
        if (previous.indexOf(command[0]) === -1) {
          completions.push(command[0])
        }
=======
    if (!current.match(/^-/)) {
      usage.getCommands().forEach(function (command) {
        completions.push(command[0])
>>>>>>> bd5102a38a195cc780d136133078667941b408c9
      })
    }

    if (current.match(/^-/)) {
      Object.keys(yargs.getOptions().key).forEach(function (key) {
        completions.push('--' + key)
      })
    }

    done(completions)
  }

  // generate the completion script to add to your .bashrc.
  self.generateCompletionScript = function ($0) {
    var script = fs.readFileSync(
      path.resolve(__dirname, '../completion.sh.hbs'),
      'utf-8'
<<<<<<< HEAD
    )
    var name = path.basename($0)
=======
    ),
    name = path.basename($0)
>>>>>>> bd5102a38a195cc780d136133078667941b408c9

    // add ./to applications not yet installed as bin.
    if ($0.match(/\.js$/)) $0 = './' + $0

    script = script.replace(/{{app_name}}/g, name)
    return script.replace(/{{app_path}}/g, $0)
  }

  // register a function to perform your own custom
  // completions., this function can be either
  // synchrnous or asynchronous.
  var completionFunction = null
  self.registerFunction = function (fn) {
    completionFunction = fn
  }

  return self
}
