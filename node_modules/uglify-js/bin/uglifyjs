#! /usr/bin/env node
// -*- js -*-

"use strict";

<<<<<<< HEAD
require("../tools/tty");

var fs = require("fs");
var info = require("../package.json");
var path = require("path");
var UglifyJS = require("../tools/node");

var skip_keys = [ "cname", "fixed", "inlined", "parent_scope", "scope", "uses_eval", "uses_with" ];
var files = {};
var options = {};
var short_forms = {
    b: "beautify",
    c: "compress",
    d: "define",
    e: "enclose",
    h: "help",
    m: "mangle",
    o: "output",
    O: "output-opts",
    p: "parse",
    v: "version",
    V: "version",
};
var args = process.argv.slice(2);
var paths = [];
var output, nameCache;
var specified = {};
while (args.length) {
    var arg = args.shift();
    if (arg[0] != "-") {
        paths.push(arg);
    } else if (arg == "--") {
        paths = paths.concat(args);
        break;
    } else if (arg[1] == "-") {
        process_option(arg.slice(2));
    } else [].forEach.call(arg.slice(1), function(letter, index, arg) {
        if (!(letter in short_forms)) fatal("invalid option -" + letter);
        process_option(short_forms[letter], index + 1 < arg.length);
    });
}

function process_option(name, no_value) {
    specified[name] = true;
    switch (name) {
      case "help":
        switch (read_value()) {
          case "ast":
            print(UglifyJS.describe_ast());
            break;
          case "options":
            var text = [];
            var toplevels = [];
            var padding = "";
            var defaults = UglifyJS.default_options();
            for (var name in defaults) {
                var option = defaults[name];
                if (option && typeof option == "object") {
                    text.push("--" + ({
                        output: "beautify",
                        sourceMap: "source-map",
                    }[name] || name) + " options:");
                    text.push(format_object(option));
                    text.push("");
                } else {
                    if (padding.length < name.length) padding = Array(name.length + 1).join(" ");
                    toplevels.push([ {
                        keep_fnames: "keep-fnames",
                        nameCache: "name-cache",
                    }[name] || name, option ]);
                }
            }
            toplevels.forEach(function(tokens) {
                text.push("--" + tokens[0] + padding.slice(tokens[0].length - 2) + tokens[1]);
            });
            print(text.join("\n"));
            break;
          default:
            print([
                "Usage: uglifyjs [files...] [options]",
                "",
                "Options:",
                "  -h, --help                               Print usage information.",
                "                                           `--help options` for details on available options.",
                "  -v, -V, --version                        Print version number.",
                "  -p, --parse <options>                    Specify parser options.",
                "  -c, --compress [options]                 Enable compressor/specify compressor options.",
                "  -m, --mangle [options]                   Mangle names/specify mangler options.",
                "  --mangle-props [options]                 Mangle properties/specify mangler options.",
                "  -b, --beautify [options]                 Beautify output/specify output options.",
                "  -O, --output-opts <options>              Output options (beautify disabled).",
                "  -o, --output <file>                      Output file (default STDOUT).",
                "  --annotations                            Process and preserve comment annotations.",
                "  --no-annotations                         Ignore and discard comment annotations.",
                "  --comments [filter]                      Preserve copyright comments in the output.",
                "  --config-file <file>                     Read minify() options from JSON file.",
                "  -d, --define <expr>[=value]              Global definitions.",
                "  -e, --enclose [arg[,...][:value[,...]]]  Embed everything in a big function, with configurable argument(s) & value(s).",
                "  --ie8                                    Support non-standard Internet Explorer 8.",
                "  --keep-fnames                            Do not mangle/drop function names. Useful for code relying on Function.prototype.name.",
                "  --name-cache <file>                      File to hold mangled name mappings.",
                "  --rename                                 Force symbol expansion.",
                "  --no-rename                              Disable symbol expansion.",
                "  --self                                   Build UglifyJS as a library (implies --wrap UglifyJS)",
                "  --source-map [options]                   Enable source map/specify source map options.",
                "  --timings                                Display operations run time on STDERR.",
                "  --toplevel                               Compress and/or mangle variables in toplevel scope.",
                "  --validate                               Perform validation during AST manipulations.",
                "  --verbose                                Print diagnostic messages.",
                "  --warn                                   Print warning messages.",
                "  --webkit                                 Support non-standard Safari/Webkit.",
                "  --wrap <name>                            Embed everything as a function with “exports” corresponding to “name” globally.",
                "",
                "(internal debug use only)",
                "  --in-situ                                Warning: replaces original source files with minified output.",
                "  --reduce-test                            Reduce a standalone test case (assumes cloned repository).",
            ].join("\n"));
        }
        process.exit();
      case "version":
        print(info.name + " " + info.version);
        process.exit();
      case "config-file":
        var config = JSON.parse(read_file(read_value(true)));
        if (config.mangle && config.mangle.properties && config.mangle.properties.regex) {
            config.mangle.properties.regex = UglifyJS.parse(config.mangle.properties.regex, {
                expression: true,
            }).value;
        }
        for (var key in config) if (!(key in options)) options[key] = config[key];
        break;
      case "compress":
      case "mangle":
        options[name] = parse_js(read_value(), options[name]);
        break;
      case "source-map":
        options.sourceMap = parse_js(read_value(), options.sourceMap);
        break;
      case "enclose":
        options[name] = read_value();
        break;
      case "annotations":
      case "ie8":
      case "timings":
      case "toplevel":
      case "validate":
      case "webkit":
        options[name] = true;
        break;
      case "no-annotations":
        options.annotations = false;
        break;
      case "keep-fnames":
        options.keep_fnames = true;
        break;
      case "wrap":
        options[name] = read_value(true);
        break;
      case "verbose":
        options.warnings = "verbose";
        break;
      case "warn":
        if (!options.warnings) options.warnings = true;
        break;
      case "beautify":
        options.output = parse_js(read_value(), options.output);
        if (!("beautify" in options.output)) options.output.beautify = true;
        break;
      case "output-opts":
        options.output = parse_js(read_value(true), options.output);
        break;
      case "comments":
        if (typeof options.output != "object") options.output = {};
        options.output.comments = read_value();
        if (options.output.comments === true) options.output.comments = "some";
        break;
      case "define":
        if (typeof options.compress != "object") options.compress = {};
        options.compress.global_defs = parse_js(read_value(true), options.compress.global_defs, "define");
        break;
      case "mangle-props":
        if (typeof options.mangle != "object") options.mangle = {};
        options.mangle.properties = parse_js(read_value(), options.mangle.properties);
        break;
      case "name-cache":
        nameCache = read_value(true);
        options.nameCache = JSON.parse(read_file(nameCache, "{}"));
        break;
      case "output":
        output = read_value(true);
        break;
      case "parse":
        options.parse = parse_js(read_value(true), options.parse);
        break;
      case "rename":
        options.rename = true;
        break;
      case "no-rename":
        options.rename = false;
        break;
      case "in-situ":
      case "reduce-test":
      case "self":
        break;
      default:
        fatal("invalid option --" + name);
    }

    function read_value(required) {
        if (no_value || !args.length || args[0][0] == "-") {
            if (required) fatal("missing option argument for --" + name);
            return true;
        }
        return args.shift();
    }
}
if (!output && options.sourceMap && options.sourceMap.url != "inline") fatal("cannot write source map to STDOUT");
if (specified["beautify"] && specified["output-opts"]) fatal("--beautify cannot be used with --output-opts");
[ "compress", "mangle" ].forEach(function(name) {
    if (!(name in options)) options[name] = false;
});
if (options.mangle && options.mangle.properties) {
    if (options.mangle.properties.domprops) {
        delete options.mangle.properties.domprops;
    } else {
        if (typeof options.mangle.properties != "object") options.mangle.properties = {};
        if (!Array.isArray(options.mangle.properties.reserved)) options.mangle.properties.reserved = [];
        require("../tools/domprops").forEach(function(name) {
            UglifyJS.push_uniq(options.mangle.properties.reserved, name);
        });
    }
}
if (output == "ast") options.output = {
    ast: true,
    code: false,
};
if (options.parse && (options.parse.acorn || options.parse.spidermonkey)
    && options.sourceMap && options.sourceMap.content == "inline") {
    fatal("inline source map only works with built-in parser");
}
if (options.warnings) {
    UglifyJS.AST_Node.log_function(print_error, options.warnings == "verbose");
    delete options.warnings;
}
var convert_path = function(name) {
    return name;
};
if (typeof options.sourceMap == "object" && "base" in options.sourceMap) {
    convert_path = function() {
        var base = options.sourceMap.base;
        delete options.sourceMap.base;
        return function(name) {
            return path.relative(base, name);
        };
    }();
}
if (specified["self"]) {
    if (paths.length) UglifyJS.AST_Node.warn("Ignoring input files since --self was passed");
    if (!options.wrap) options.wrap = "UglifyJS";
    paths = UglifyJS.FILES;
}
if (specified["in-situ"]) {
    if (output || specified["reduce-test"] || specified["self"]) fatal("incompatible options specified");
    paths.forEach(function(name) {
        print(name);
        if (/^ast|spidermonkey$/.test(name)) fatal("invalid file name specified");
        files = {};
        files[convert_path(name)] = read_file(name);
        output = name;
        run();
    });
} else if (paths.length) {
    simple_glob(paths).forEach(function(name) {
        files[convert_path(name)] = read_file(name);
    });
    run();
} else {
    var timerId = process.stdin.isTTY && process.argv.length < 3 && setTimeout(function() {
        print_error("Waiting for input... (use `--help` to print usage information)");
    }, 1500);
    var chunks = [];
    process.stdin.setEncoding("utf8");
    process.stdin.once("data", function() {
        clearTimeout(timerId);
    }).on("data", function(chunk) {
        chunks.push(chunk);
    }).on("end", function() {
        files = { STDIN: chunks.join("") };
        run();
    });
    process.stdin.resume();
}

function convert_ast(fn) {
    return UglifyJS.AST_Node.from_mozilla_ast(Object.keys(files).reduce(fn, null));
}

function run() {
    var content = options.sourceMap && options.sourceMap.content;
    if (content && content != "inline") {
        UglifyJS.AST_Node.info("Using input source map: {content}", {
            content : content,
        });
        options.sourceMap.content = read_file(content, content);
    }
    try {
        if (options.parse) {
            if (options.parse.acorn) {
                files = convert_ast(function(toplevel, name) {
                    return require("acorn").parse(files[name], {
                        locations: true,
                        program: toplevel,
                        sourceFile: name
                    });
                });
            } else if (options.parse.spidermonkey) {
                files = convert_ast(function(toplevel, name) {
                    var obj = JSON.parse(files[name]);
                    if (!toplevel) return obj;
                    toplevel.body = toplevel.body.concat(obj.body);
                    return toplevel;
                });
            }
        }
    } catch (ex) {
        fatal(ex);
    }
    var result;
    if (specified["reduce-test"]) {
        // load on demand - assumes cloned repository
        var reduce_test = require("../test/reduce");
        if (Object.keys(files).length != 1) fatal("can only test on a single file");
        result = reduce_test(files[Object.keys(files)[0]], options, {
            log: print_error,
            verbose: true,
        });
    } else {
        result = UglifyJS.minify(files, options);
    }
    if (result.error) {
        var ex = result.error;
        if (ex.name == "SyntaxError") {
            print_error("Parse error at " + ex.filename + ":" + ex.line + "," + ex.col);
            var file = files[ex.filename];
            if (file) {
                var col = ex.col;
                var lines = file.split(/\r?\n/);
                var line = lines[ex.line - 1];
                if (!line && !col) {
                    line = lines[ex.line - 2];
                    col = line.length;
                }
                if (line) {
                    var limit = 70;
                    if (col > limit) {
                        line = line.slice(col - limit);
                        col = limit;
                    }
                    print_error(line.slice(0, 80));
                    print_error(line.slice(0, col).replace(/\S/g, " ") + "^");
                }
            }
        } else if (ex.defs) {
            print_error("Supported options:");
            print_error(format_object(ex.defs));
        }
        fatal(ex);
    } else if (output == "ast") {
        if (!options.compress && !options.mangle) {
            var toplevel = result.ast;
            if (!(toplevel instanceof UglifyJS.AST_Toplevel)) {
                if (!(toplevel instanceof UglifyJS.AST_Statement)) toplevel = new UglifyJS.AST_SimpleStatement({
                    body: toplevel,
                });
                toplevel = new UglifyJS.AST_Toplevel({
                    body: [ toplevel ],
                });
            }
            toplevel.figure_out_scope({});
        }
        print(JSON.stringify(result.ast, function(key, value) {
            if (value) switch (key) {
              case "enclosed":
                return value.length ? value.map(symdef) : undefined;
              case "functions":
              case "globals":
              case "variables":
                return value.size() ? value.map(symdef) : undefined;
              case "thedef":
                return symdef(value);
            }
            if (skip_key(key)) return;
            if (value instanceof UglifyJS.AST_Token) return;
            if (value instanceof UglifyJS.Dictionary) return;
            if (value instanceof UglifyJS.AST_Node) {
                var result = {
                    _class: "AST_" + value.TYPE
                };
                value.CTOR.PROPS.forEach(function(prop) {
                    result[prop] = value[prop];
                });
                return result;
            }
            return value;
        }, 2));
    } else if (output == "spidermonkey") {
        print(JSON.stringify(UglifyJS.minify(result.code, {
            compress: false,
            mangle: false,
            output: {
                ast: true,
                code: false
            },
        }).ast.to_mozilla_ast(), null, 2));
    } else if (output) {
        fs.writeFileSync(output, result.code);
        if (result.map) fs.writeFileSync(output + ".map", result.map);
    } else {
        print(result.code);
    }
    if (nameCache) fs.writeFileSync(nameCache, JSON.stringify(options.nameCache));
    if (result.timings) for (var phase in result.timings) {
        print_error("- " + phase + ": " + result.timings[phase].toFixed(3) + "s");
    }
}

function fatal(message) {
    if (message instanceof Error) {
        message = message.stack.replace(/^\S*?Error:/, "ERROR:")
    } else {
        message = "ERROR: " + message;
    }
    print_error(message);
    process.exit(1);
}

// A file glob function that only supports "*" and "?" wildcards in the basename.
// Example: "foo/bar/*baz??.*.js"
// Argument `glob` may be a string or an array of strings.
// Returns an array of strings. Garbage in, garbage out.
function simple_glob(glob) {
    if (Array.isArray(glob)) {
        return [].concat.apply([], glob.map(simple_glob));
    }
    if (glob.match(/\*|\?/)) {
        var dir = path.dirname(glob);
        try {
            var entries = fs.readdirSync(dir);
        } catch (ex) {}
        if (entries) {
            var pattern = "^" + path.basename(glob)
                .replace(/[.+^$[\]\\(){}]/g, "\\$&")
                .replace(/\*/g, "[^/\\\\]*")
                .replace(/\?/g, "[^/\\\\]") + "$";
            var mod = process.platform === "win32" ? "i" : "";
            var rx = new RegExp(pattern, mod);
            var results = entries.sort().filter(function(name) {
                return rx.test(name);
            }).map(function(name) {
                return path.join(dir, name);
            });
            if (results.length) return results;
        }
    }
    return [ glob ];
}

function read_file(path, default_value) {
    try {
        return fs.readFileSync(path, "utf8");
    } catch (ex) {
        if (ex.code == "ENOENT" && default_value != null) return default_value;
        fatal(ex);
    }
}

function parse_js(value, options, flag) {
    if (!options || typeof options != "object") options = {};
    if (typeof value == "string") try {
        UglifyJS.parse(value, {
            expression: true
        }).walk(new UglifyJS.TreeWalker(function(node) {
            if (node instanceof UglifyJS.AST_Assign) {
                var name = node.left.print_to_string();
                var value = node.right;
                if (flag) {
                    options[name] = value;
                } else if (value instanceof UglifyJS.AST_Array) {
                    options[name] = value.elements.map(to_string);
                } else {
                    options[name] = to_string(value);
                }
                return true;
            }
            if (node instanceof UglifyJS.AST_Symbol || node instanceof UglifyJS.AST_PropAccess) {
                var name = node.print_to_string();
                options[name] = true;
                return true;
            }
            if (!(node instanceof UglifyJS.AST_Sequence)) throw node;

            function to_string(value) {
                return value instanceof UglifyJS.AST_Constant ? value.value : value.print_to_string({
                    quote_keys: true
                });
            }
        }));
    } catch (ex) {
        if (flag) {
            fatal("cannot parse arguments for '" + flag + "': " + value);
        } else {
            options[value] = null;
        }
    }
    return options;
}

function skip_key(key) {
    return skip_keys.indexOf(key) >= 0;
}

function symdef(def) {
    var ret = (1e6 + def.id) + " " + def.name;
    if (def.mangled_name) ret += " " + def.mangled_name;
    return ret;
}

function format_object(obj) {
    var lines = [];
    var padding = "";
    Object.keys(obj).map(function(name) {
        if (padding.length < name.length) padding = Array(name.length + 1).join(" ");
        return [ name, JSON.stringify(obj[name]) ];
    }).forEach(function(tokens) {
        lines.push("  " + tokens[0] + padding.slice(tokens[0].length - 2) + tokens[1]);
    });
    return lines.join("\n");
}

function print_error(msg) {
    process.stderr.write(msg);
    process.stderr.write("\n");
}

function print(txt) {
    process.stdout.write(txt);
    process.stdout.write("\n");
=======
var UglifyJS = require("../tools/node");
var sys = require("util");
var yargs = require("yargs");
var fs = require("fs");
var path = require("path");
var acorn;
var screw_ie8 = true;
var ARGS = yargs
    .usage("$0 input1.js [input2.js ...] [options]\n\
Use a single dash to read input from the standard input.\
\n\n\
NOTE: by default there is no mangling/compression.\n\
Without [options] it will simply parse input files and dump the AST\n\
with whitespace and comments discarded.  To achieve compression and\n\
mangling you need to use `-c` and `-m`.\
")
    .describe("source-map", "Specify an output file where to generate source map.")
    .describe("source-map-root", "The path to the original source to be included in the source map.")
    .describe("source-map-url", "The path to the source map to be added in //# sourceMappingURL.  Defaults to the value passed with --source-map.")
    .describe("source-map-inline", "Write base64-encoded source map to the end of js output.  Disabled by default")
    .describe("source-map-include-sources", "Pass this flag if you want to include the content of source files in the source map as sourcesContent property.")
    .describe("in-source-map", "Input source map, useful if you're compressing JS that was generated from some other original code.")
    .describe("screw-ie8", "Do not support Internet Explorer 6/7/8. This flag is enabled by default.")
    .describe("support-ie8", "Support non-standard Internet Explorer 6/7/8 javascript.")
    .describe("expr", "Parse a single expression, rather than a program (for parsing JSON)")
    .describe("p", "Skip prefix for original filenames that appear in source maps. \
For example -p 3 will drop 3 directories from file names and ensure they are relative paths. \
You can also specify -p relative, which will make UglifyJS figure out itself the relative paths between original sources, \
the source map and the output file.")
    .describe("o", "Output file (default STDOUT).")
    .describe("b", "Beautify output/specify output options.")
    .describe("m", "Mangle names/pass mangler options.")
    .describe("r", "Reserved names to exclude from mangling.")
    .describe("c", "Enable compressor/pass compressor options. \
Pass options like -c hoist_vars=false,if_return=false. \
Use -c with no argument to use the default compression options.")
    .describe("d", "Global definitions")
    .describe("e", "Embed everything in a big function, with a configurable parameter/argument list.")

    .describe("comments", "Preserve copyright comments in the output. \
By default this works like Google Closure, keeping JSDoc-style comments that contain \"@license\" or \"@preserve\". \
You can optionally pass one of the following arguments to this flag:\n\
- \"all\" to keep all comments\n\
- a valid JS RegExp like `/foo/`or `/^!/` to keep only matching comments.\n\
\
Note that currently not *all* comments can be kept when compression is on, \
because of dead code removal or cascading statements into sequences.")

    .describe("preamble", "Preamble to prepend to the output.  You can use this to insert a \
comment, for example for licensing information.  This will not be \
parsed, but the source map will adjust for its presence.")

    .describe("stats", "Display operations run time on STDERR.")
    .describe("acorn", "Use Acorn for parsing.")
    .describe("spidermonkey", "Assume input files are SpiderMonkey AST format (as JSON).")
    .describe("self", "Build itself (UglifyJS2) as a library (implies --wrap=UglifyJS --export-all)")
    .describe("wrap", "Embed everything in a big function, making the “exports” and “global” variables available. \
You need to pass an argument to this option to specify the name that your module will take when included in, say, a browser.")
    .describe("export-all", "Only used when --wrap, this tells UglifyJS to add code to automatically export all globals.")
    .describe("lint", "Display some scope warnings")
    .describe("v", "Verbose")
    .describe("V", "Print version number and exit.")
    .describe("noerr", "Don't throw an error for unknown options in -c, -b or -m.")
    .describe("bare-returns", "Allow return outside of functions.  Useful when minifying CommonJS modules.")
    .describe("keep-fnames", "Do not mangle/drop function names.  Useful for code relying on Function.prototype.name.")
    .describe("quotes", "Quote style (0 - auto, 1 - single, 2 - double, 3 - original)")
    .describe("reserved-file", "File containing reserved names")
    .describe("reserve-domprops", "Make (most?) DOM properties reserved for --mangle-props")
    .describe("mangle-props", "Mangle property names (0 - disabled, 1 - mangle all properties, 2 - mangle unquoted properies)")
    .describe("mangle-regex", "Only mangle property names matching the regex")
    .describe("name-cache", "File to hold mangled names mappings")
    .describe("pure-funcs", "List of functions that can be safely removed if their return value is not used")
    .describe("dump-spidermonkey-ast", "Dump SpiderMonkey AST to stdout.")
    .describe("wrap-iife", "Wrap IIFEs in parenthesis. Note: this disables the negate_iife compression option")

    .alias("p", "prefix")
    .alias("o", "output")
    .alias("v", "verbose")
    .alias("b", "beautify")
    .alias("m", "mangle")
    .alias("c", "compress")
    .alias("d", "define")
    .alias("r", "reserved")
    .alias("V", "version")
    .alias("e", "enclose")
    .alias("q", "quotes")

    .string("source-map")
    .string("source-map-root")
    .string("source-map-url")
    .string("b")
    .string("beautify")
    .string("m")
    .string("mangle")
    .string("mangle-props-debug")
    .string("c")
    .string("compress")
    .string("d")
    .string("define")
    .string("e")
    .string("enclose")
    .string("comments")
    .string("wrap")
    .string("p")
    .string("prefix")
    .string("name-cache")

    .array("reserved-file")
    .array("pure-funcs")

    .boolean("expr")
    .boolean("source-map-inline")
    .boolean("source-map-include-sources")
    .boolean("screw-ie8")
    .boolean("support-ie8")
    .boolean("export-all")
    .boolean("self")
    .boolean("v")
    .boolean("verbose")
    .boolean("stats")
    .boolean("acorn")
    .boolean("spidermonkey")
    .boolean("dump-spidermonkey-ast")
    .boolean("lint")
    .boolean("V")
    .boolean("version")
    .boolean("noerr")
    .boolean("bare-returns")
    .boolean("keep-fnames")
    .boolean("reserve-domprops")
    .boolean("wrap-iife")

    .wrap(80)

    .argv
;

normalize(ARGS);

if (ARGS.noerr) {
    UglifyJS.DefaultsError.croak = function(msg, defs) {
        print_error("WARN: " + msg);
    };
}

if (ARGS.version || ARGS.V) {
    var json = require("../package.json");
    print(json.name + ' ' + json.version);
    process.exit(0);
}

if (ARGS.ast_help) {
    var desc = UglifyJS.describe_ast();
    print(typeof desc == "string" ? desc : JSON.stringify(desc, null, 2));
    process.exit(0);
}

if (ARGS.h || ARGS.help) {
    print(yargs.help());
    process.exit(0);
}

if (ARGS.acorn) {
    acorn = require("acorn");
}

var COMPRESS = getOptions("c", true);
var MANGLE = getOptions("m", true);
var BEAUTIFY = getOptions("b", true);
var RESERVED = null;

if (ARGS.reserved_file) ARGS.reserved_file.forEach(function(filename){
    RESERVED = UglifyJS.readReservedFile(filename, RESERVED);
});

if (ARGS.reserve_domprops) {
    RESERVED = UglifyJS.readDefaultReservedFile(RESERVED);
}

if (ARGS.d) {
    if (COMPRESS) COMPRESS.global_defs = getOptions("d");
}

if (ARGS.pure_funcs) {
    if (COMPRESS) COMPRESS.pure_funcs = ARGS.pure_funcs;
}

if (ARGS.r) {
    if (MANGLE) MANGLE.except = ARGS.r.replace(/^\s+|\s+$/g).split(/\s*,+\s*/);
}

if (RESERVED && MANGLE) {
    if (!MANGLE.except) MANGLE.except = RESERVED.vars;
    else MANGLE.except = MANGLE.except.concat(RESERVED.vars);
}

function readNameCache(key) {
    return UglifyJS.readNameCache(ARGS.name_cache, key);
}

function writeNameCache(key, cache) {
    return UglifyJS.writeNameCache(ARGS.name_cache, key, cache);
}

function extractRegex(str) {
  if (/^\/.*\/[a-zA-Z]*$/.test(str)) {
    var regex_pos = str.lastIndexOf("/");
    return new RegExp(str.substr(1, regex_pos - 1), str.substr(regex_pos + 1));
  } else {
    throw new Error("Invalid regular expression: " + str);
  }
}

if (ARGS.quotes === true) {
    ARGS.quotes = 3;
}

if (ARGS.mangle_props === true) {
    ARGS.mangle_props = 1;
} else if (ARGS.mangle_props === "unquoted") {
    ARGS.mangle_props = 2;
}

var OUTPUT_OPTIONS = {
    beautify     : BEAUTIFY ? true : false,
    max_line_len : 32000,
    preamble     : ARGS.preamble || null,
    quote_style  : ARGS.quotes != null ? ARGS.quotes : 0,
};

if (ARGS.mangle_props == 2) {
    OUTPUT_OPTIONS.keep_quoted_props = true;
    if (COMPRESS && !("properties" in COMPRESS))
        COMPRESS.properties = false;
}

if (ARGS.support_ie8 === true && ARGS.screw_ie8 !== true) {
    screw_ie8 = false;
}

if (COMPRESS) COMPRESS.screw_ie8 = screw_ie8;
if (MANGLE) MANGLE.screw_ie8 = screw_ie8;
OUTPUT_OPTIONS.screw_ie8 = screw_ie8;

if (ARGS.keep_fnames) {
    if (COMPRESS) COMPRESS.keep_fnames = true;
    if (MANGLE) MANGLE.keep_fnames = true;
}

if (ARGS.wrap_iife) {
    if (COMPRESS) COMPRESS.negate_iife = false;
    OUTPUT_OPTIONS.wrap_iife = true;
}

if (BEAUTIFY)
    UglifyJS.merge(OUTPUT_OPTIONS, BEAUTIFY);

if (ARGS.comments === "") {
    OUTPUT_OPTIONS.comments = "some";
} else {
    OUTPUT_OPTIONS.comments = ARGS.comments;
}

var files = ARGS._.slice();

if (process.platform === "win32")
    files = UglifyJS.simple_glob(files);

if (ARGS.self) {
    if (files.length > 0) {
        print_error("WARN: Ignoring input files since --self was passed");
    }
    files = UglifyJS.FILES;
    if (!ARGS.wrap) ARGS.wrap = "UglifyJS";
}

var ORIG_MAP = ARGS.in_source_map;

if (ORIG_MAP && ORIG_MAP != "inline") {
    ORIG_MAP = JSON.parse(fs.readFileSync(ORIG_MAP));
    if (files.length == 0) {
        print_error("INFO: Using file from the input source map: " + ORIG_MAP.file);
        files = [ ORIG_MAP.file ];
    }
}

if (files.length == 0) {
    files = [ "-" ];
}

if (ORIG_MAP == "inline") {
    if (files.length > 1) {
        print_error("ERROR: Inline source map only works with singular input");
        process.exit(1);
    }
    if (ARGS.acorn || ARGS.spidermonkey) {
        print_error("ERROR: Inline source map only works with built-in parser");
        process.exit(1);
    }
}

if (files.indexOf("-") >= 0 && ARGS.source_map) {
    print_error("ERROR: Source map doesn't work with input from STDIN");
    process.exit(1);
}

if (files.filter(function(el){ return el == "-" }).length > 1) {
    print_error("ERROR: Can read a single file from STDIN (two or more dashes specified)");
    process.exit(1);
}

var STATS = {};
var TOPLEVEL = null;
var P_RELATIVE = ARGS.p && ARGS.p == "relative";
var SOURCES_CONTENT = {};
var index = 0;

!function cb() {
    if (index == files.length) return done();
    var file = files[index++];
    read_whole_file(file, function (err, code) {
        if (err) {
            print_error("ERROR: can't read file: " + file);
            process.exit(1);
        }
        if (ORIG_MAP == "inline") {
            ORIG_MAP = read_source_map(code);
        }
        if (ARGS.p != null) {
            if (P_RELATIVE) {
                file = path.relative(path.dirname(ARGS.source_map), file).replace(/\\/g, '/');
            } else {
                var p = parseInt(ARGS.p, 10);
                if (!isNaN(p)) {
                    file = file.replace(/^\/+/, "").split(/\/+/).slice(ARGS.p).join("/");
                }
            }
        }
        SOURCES_CONTENT[file] = code;
        time_it("parse", function(){
            if (ARGS.spidermonkey) {
                var program = JSON.parse(code);
                if (!TOPLEVEL) TOPLEVEL = program;
                else TOPLEVEL.body = TOPLEVEL.body.concat(program.body);
            }
            else if (ARGS.acorn) {
                TOPLEVEL = acorn.parse(code, {
                    locations     : true,
                    sourceFile    : file,
                    program       : TOPLEVEL
                });
            }
            else {
                try {
                    TOPLEVEL = UglifyJS.parse(code, {
                        filename     : file,
                        toplevel     : TOPLEVEL,
                        expression   : ARGS.expr,
                        bare_returns : ARGS.bare_returns,
                    });
                } catch(ex) {
                    if (ex instanceof UglifyJS.JS_Parse_Error) {
                        print_error("Parse error at " + file + ":" + ex.line + "," + ex.col);
                        var col = ex.col;
                        var lines = code.split(/\r?\n/);
                        var line = lines[ex.line - 1];
                        if (!line && !col) {
                            line = lines[ex.line - 2];
                            col = line.length;
                        }
                        if (line) {
                            if (col > 40) {
                                line = line.slice(col - 40);
                                col = 40;
                            }
                            print_error(line.slice(0, 80));
                            print_error(line.slice(0, col).replace(/\S/g, " ") + "^");
                        }
                        print_error(ex.stack);
                        process.exit(1);
                    }
                    throw ex;
                }
            };
        });
        cb();
    });
}();

function done() {
    var OUTPUT_FILE = ARGS.o;

    var SOURCE_MAP = (ARGS.source_map || ARGS.source_map_inline) ? UglifyJS.SourceMap({
        file: P_RELATIVE ? path.relative(path.dirname(ARGS.source_map), OUTPUT_FILE) : OUTPUT_FILE,
        root: ARGS.source_map_root || ORIG_MAP && ORIG_MAP.sourceRoot,
        orig: ORIG_MAP,
    }) : null;

    OUTPUT_OPTIONS.source_map = SOURCE_MAP;

    try {
        var output = UglifyJS.OutputStream(OUTPUT_OPTIONS);
        var compressor = COMPRESS && UglifyJS.Compressor(COMPRESS);
    } catch(ex) {
        if (ex instanceof UglifyJS.DefaultsError) {
            print_error(ex.message);
            print_error("Supported options:");
            print_error(sys.inspect(ex.defs));
            process.exit(1);
        }
    }

    if (ARGS.acorn || ARGS.spidermonkey) time_it("convert_ast", function(){
        TOPLEVEL = UglifyJS.AST_Node.from_mozilla_ast(TOPLEVEL);
    });

    if (ARGS.wrap != null) {
        TOPLEVEL = TOPLEVEL.wrap_commonjs(ARGS.wrap, ARGS.export_all);
    }

    if (ARGS.enclose != null) {
        var arg_parameter_list = ARGS.enclose;
        if (arg_parameter_list === true) {
            arg_parameter_list = [];
        }
        else if (!(arg_parameter_list instanceof Array)) {
            arg_parameter_list = [arg_parameter_list];
        }
        TOPLEVEL = TOPLEVEL.wrap_enclose(arg_parameter_list);
    }

    if (ARGS.mangle_props || ARGS.name_cache) (function(){
        var reserved = RESERVED ? RESERVED.props : null;
        var cache = readNameCache("props");
        var regex;

        try {
          regex = ARGS.mangle_regex ? extractRegex(ARGS.mangle_regex) : null;
        } catch (e) {
            print_error("ERROR: Invalid --mangle-regex: " + e.message);
            process.exit(1);
        }

        TOPLEVEL = UglifyJS.mangle_properties(TOPLEVEL, {
            reserved      : reserved,
            cache         : cache,
            only_cache    : !ARGS.mangle_props,
            regex         : regex,
            ignore_quoted : ARGS.mangle_props == 2,
            debug         : typeof ARGS.mangle_props_debug === "undefined" ? false : ARGS.mangle_props_debug
        });
        writeNameCache("props", cache);
    })();

    var SCOPE_IS_NEEDED = COMPRESS || MANGLE || ARGS.lint
    var TL_CACHE = readNameCache("vars");
    if (MANGLE) MANGLE.cache = TL_CACHE;

    if (SCOPE_IS_NEEDED) {
        time_it("scope", function(){
            TOPLEVEL.figure_out_scope(MANGLE || { screw_ie8: screw_ie8, cache: TL_CACHE });
            if (ARGS.lint) {
                TOPLEVEL.scope_warnings();
            }
        });
    }

    if (COMPRESS) {
        time_it("squeeze", function(){
            TOPLEVEL = compressor.compress(TOPLEVEL);
        });
    }

    if (SCOPE_IS_NEEDED) {
        time_it("scope", function(){
            TOPLEVEL.figure_out_scope(MANGLE || { screw_ie8: screw_ie8, cache: TL_CACHE });
            if (MANGLE && !TL_CACHE) {
                TOPLEVEL.compute_char_frequency(MANGLE);
            }
        });
    }

    if (MANGLE) time_it("mangle", function(){
        TOPLEVEL.mangle_names(MANGLE);
    });

    writeNameCache("vars", TL_CACHE);

    if (ARGS.source_map_include_sources) {
        for (var file in SOURCES_CONTENT) {
            if (SOURCES_CONTENT.hasOwnProperty(file)) {
                SOURCE_MAP.get().setSourceContent(file, SOURCES_CONTENT[file]);
            }
        }
    }

    if (ARGS.dump_spidermonkey_ast) {
        print(JSON.stringify(TOPLEVEL.to_mozilla_ast(), null, 2));
    } else {
        time_it("generate", function(){
            TOPLEVEL.print(output);
        });

        output = output.get();

        if (SOURCE_MAP) {
            if (ARGS.source_map_inline) {
                var base64_string = new Buffer(SOURCE_MAP.toString()).toString('base64');
                output += "\n//# sourceMappingURL=data:application/json;charset=utf-8;base64," + base64_string;
            } else {
                fs.writeFileSync(ARGS.source_map, SOURCE_MAP, "utf8");
                var source_map_url = ARGS.source_map_url || (
                    P_RELATIVE
                        ? path.relative(path.dirname(OUTPUT_FILE), ARGS.source_map)
                        : ARGS.source_map
                );
                output += "\n//# sourceMappingURL=" + source_map_url;
            }
        }

        if (OUTPUT_FILE) {
            fs.writeFileSync(OUTPUT_FILE, output, "utf8");
        } else {
            print(output);
        }
    }

    if (ARGS.stats) {
        print_error(UglifyJS.string_template("Timing information (compressed {count} files):", {
            count: files.length
        }));
        for (var i in STATS) if (STATS.hasOwnProperty(i)) {
            print_error(UglifyJS.string_template("- {name}: {time}s", {
                name: i,
                time: (STATS[i] / 1000).toFixed(3)
            }));
        }
    }
}

/* -----[ functions ]----- */

function normalize(o) {
    for (var i in o) if (o.hasOwnProperty(i) && /-/.test(i)) {
        o[i.replace(/-/g, "_")] = o[i];
        delete o[i];
    }
}

function getOptions(flag, constants) {
    var x = ARGS[flag];
    if (x == null || x === false) return null;
    var ret = {};
    if (x !== "") {
        if (Array.isArray(x)) x = x.map(function (v) { return "(" + v + ")"; }).join(", ");

        var ast;
        try {
            ast = UglifyJS.parse(x, { cli: true, expression: true });
        } catch(ex) {
            if (ex instanceof UglifyJS.JS_Parse_Error) {
                print_error("Error parsing arguments for flag `" + flag + "': " + x);
                process.exit(1);
            }
        }
        ast.walk(new UglifyJS.TreeWalker(function(node){
            if (node instanceof UglifyJS.AST_Seq) return; // descend
            if (node instanceof UglifyJS.AST_Assign) {
                var name = node.left.print_to_string().replace(/-/g, "_");
                var value = node.right;
                if (constants)
                    value = new Function("return (" + value.print_to_string() + ")")();
                ret[name] = value;
                return true;    // no descend
            }
            if (node instanceof UglifyJS.AST_Symbol || node instanceof UglifyJS.AST_Binary) {
                var name = node.print_to_string().replace(/-/g, "_");
                ret[name] = true;
                return true;    // no descend
            }
            print_error(node.TYPE)
            print_error("Error parsing arguments for flag `" + flag + "': " + x);
            process.exit(1);
        }));
    }
    return ret;
}

function read_whole_file(filename, cb) {
    if (filename == "-") {
        var chunks = [];
        process.stdin.setEncoding('utf-8');
        process.stdin.on('data', function (chunk) {
            chunks.push(chunk);
        }).on('end', function () {
            cb(null, chunks.join(""));
        });
        process.openStdin();
    } else {
        fs.readFile(filename, "utf-8", cb);
    }
}

function read_source_map(code) {
    var match = /\n\/\/# sourceMappingURL=data:application\/json(;.*?)?;base64,(.*)/.exec(code);
    if (!match) {
        print_error("WARN: inline source map not found");
        return null;
    }
    return JSON.parse(new Buffer(match[2], "base64"));
}

function time_it(name, cont) {
    var t1 = new Date().getTime();
    var ret = cont();
    if (ARGS.stats) {
        var spent = new Date().getTime() - t1;
        if (STATS[name]) STATS[name] += spent;
        else STATS[name] = spent;
    }
    return ret;
}

function print_error(msg) {
    console.error("%s", msg);
}

function print(txt) {
    console.log("%s", txt);
>>>>>>> bd5102a38a195cc780d136133078667941b408c9
}
